#define NoOfShop 2000; // 2000 shop
#define NoOfFloors 10; // Expo is a hall with 10 floor
#define NoOfEvents 2;
#define NoOfPlaces 2;
#define NoOfGroups 4;
#define NoOfVisitors 5;
#define lobbyCapacity 20;

var eventAvailable[NoOfEvents] = [5, 10];//, 6, 7, 5];
var visitorsGroups[NoOfGroups] = [50, 40, 60, 20];
var visited[NoOfVisitors][NoOfEvents];
var visitors[NoOfVisitors];
var visting[NoOfVisitors];
var cusVisited = 0;
var lobbyCount = 0;
	
//Event() = |||i:{0..NoOfVisitors}@Visitor(i,0);
//Visitor(i,j) =  [cap[j] == 0] Visitor(i,(j+1)%NoOfEvents)
//	[] [cap[j] > 0] Buying(i,j);
//
//
//Buying(i,j) = {cusVisited = cusVisited+1; cap[j] = cap[j] -1} -> Leave(i,j);
//Leave(i,j) = {cap[j] = cap[j] + 1}->Visitor(i,(j+1)%NoOfEvents);

//#assert Event() reaches allCusHappy;


//Event will be occured at place. each place can only hold one event.

//expoEvent(i) = book.i -> setUp.i -> openForVisit.i -> close.i -> Skip;
expoEvent(i) = book.i -> close.i -> Skip;
//expoPlace(j) = available.j -> ([] i:{0..NoOfEvents-1}@(book.i -> eventRunningOn.j -> close.i -> eventEnd.j -> expoPlace(j))); oo
// deadlock! <init -> available.1 -> available.0 -> book.1 -> eventRunningOn.1 -> eventRunningOn.0 -> close.1 -> eventEnd.1 -> available.1 -> eventEnd.0 -> available.0 -> book.0 -> eventRunningOn.1 -> eventRunningOn.0 -> close.0 -> eventEnd.1 -> available.1 -> eventEnd.0 -> available.0>

//rewrite
expoPlace(j) = available.j -> ([] i:{0..NoOfEvents-1}@(book.i -> eventRunningOn.j -> close.i -> eventEnd.j -> expoPlace(j))); 
//deadlock! <init -> available.1 -> available.0 -> book.1 -> eventRunningOn.1 -> eventRunningOn.0 -> close.1 -> eventEnd.1 -> available.1 -> eventEnd.0 -> available.0 -> book.0 -> eventRunningOn.1 -> eventRunningOn.0 -> close.0 -> eventEnd.1 -> available.1 -> eventEnd.0 -> available.0>


//expoPlace(j) = []i:{0..NoOfEvent-1}@(book.i -> placeOccupied.j -> setUp.i -> close.i -> expoPlace(j));
System() = (|| i:{0..NoOfEvents-1}@expoEvent(i)) || (|| j:{0..NoOfPlaces-1}@(expoPlace(j)));

//visitors Process

VisitorInsideExpo(k) = ([] j:{0..NoOfEvents-1}@([eventAvailable[j] > 0 && visting[k] == 0 && visited[k][j] == 0] visit.k.j {
		eventAvailable[j] = eventAvailable[j] - 1;
		visited[k][j] = 1;
		visting[k] = 1;
		lobbyCount = lobbyCount - 1; 
	}
	-> ([lobbyCount < lobbyCapacity] leave.k.j {
		eventAvailable[j] = eventAvailable[j] + 1;
		visting[k] = 0;
		lobbyCount = lobbyCount + 1;
	} 
	-> VisitorInsideExpo(k))))
	[] ([&& j:{0..NoOfEvents-1}@(visited[k][j] == 1)] visitedAll.k
	-> Skip);
	
Visitor(k) = [lobbyCount < lobbyCapacity] enterExpo.k {
		lobbyCount = lobbyCount + 1;
	} 
	-> Skip; 
VisitorInsideExpo(k); 
leaveExpo.k {
		lobbyCount = lobbyCount - 1;
	} -> Skip;
	
VisitorSystem() = || k:{0..NoOfVisitors-1}@(Visitor(k));
#define allCusHappy (&& k:{0..NoOfVisitors-1}@(&& j:{0..NoOfEvents-1}@(visited[k][j] == 1)));
#assert VisitorSystem() reaches allCusHappy;
#define someCusNotHappy (|| k:{0..NoOfVisitors-1}@(|| j:{0..NoOfEvents-1}@(visited[k][j] == 0)));
#assert VisitorSystem() reaches someCusNotHappy;
#assert System() deadlockfree;
#assert VisitorSystem() deadlockfree;
		  
//TODO: assert if at at anytime, event cannot hold customers