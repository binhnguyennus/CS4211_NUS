#define NoOfShop 2000; // 2000 shop
#define NoOfFloors 10; // Expo is a hall with 10 floor
#define NoOfEvents 2;
#define NoOfPlaces 2;
#define NoOfGroups 4;
#define NoOfVisitors 2;
#define lobbyCapacity 20;
#define visDuration 1;
var maxTime = 10;

var eventAvailable[NoOfEvents] = [1, 1];//, 6, 7, 5];
var visitorsGroups[NoOfGroups] = [50, 40, 60, 20];
var visited[NoOfVisitors][NoOfEvents];
var visitors[NoOfVisitors];
var visting[NoOfVisitors];
var curTime[NoOfVisitors];
var cusVisited = 0;
var lobbyCount = 0;
var tick = 0;
var numVisAll = 0;

//Event will be occured at place. each place can only hold one event.

//expoEvent(i) = book.i -> setUp.i -> openForVisit.i -> close.i -> Skip;
expoEvent(i) = book.i -> close.i -> Skip;
//expoPlace(j) = available.j -> ([] i:{0..NoOfEvents-1}@(book.i -> eventRunningOn.j -> close.i -> eventEnd.j -> expoPlace(j))); oo
// deadlock! <init -> available.1 -> available.0 -> book.1 -> eventRunningOn.1 -> eventRunningOn.0 -> close.1 -> eventEnd.1 -> available.1 -> eventEnd.0 -> available.0 -> book.0 -> eventRunningOn.1 -> eventRunningOn.0 -> close.0 -> eventEnd.1 -> available.1 -> eventEnd.0 -> available.0>

//rewrite
expoPlace(j) = available.j -> ([] i:{0..NoOfEvents-1}@(book.i -> eventRunningOn.j -> close.i -> eventEnd.j -> expoPlace(j))); 
//deadlock! <init -> available.1 -> available.0 -> book.1 -> eventRunningOn.1 -> eventRunningOn.0 -> close.1 -> eventEnd.1 -> available.1 -> eventEnd.0 -> available.0 -> book.0 -> eventRunningOn.1 -> eventRunningOn.0 -> close.0 -> eventEnd.1 -> available.1 -> eventEnd.0 -> available.0>


//expoPlace(j) = []i:{0..NoOfEvent-1}@(book.i -> placeOccupied.j -> setUp.i -> close.i -> expoPlace(j));
System() = (|| i:{0..NoOfEvents-1}@expoEvent(i)) || (|| j:{0..NoOfPlaces-1}@(expoPlace(j)));

//visitors Process

VisitorInsideExpo(k) = ([] j:{0..NoOfEvents-1}@([curTime[k] == tick && eventAvailable[j] > 0 && visting[k] == 0 && visited[k][j] == 0] visit.k.j {
		eventAvailable[j] = eventAvailable[j] - 1;
		visited[k][j] = 1;
		visting[k] = 1;
		lobbyCount = lobbyCount - 1; 
		curTime[k] = curTime[k] + visDuration;
	}
	-> ([curTime[k] == tick && lobbyCount < lobbyCapacity] leave.k.j {
		eventAvailable[j] = eventAvailable[j] + 1;
		visting[k] = 0;
		lobbyCount = lobbyCount + 1;
	} 
	-> VisitorInsideExpo(k))))
	[] ([(curTime[k] == tick) && (&& j:{0..NoOfEvents-1}@(visited[k][j] == 1))] visitedAll.k {
		numVisAll = numVisAll + 1;
	}
	-> Skip);
	
Visitor(k) = [lobbyCount < lobbyCapacity] enterExpo.k {
		lobbyCount = lobbyCount + 1;
		curTime[k] = tick;
	} 
	-> Skip; 
VisitorInsideExpo(k); 
leaveExpo.k {
		lobbyCount = lobbyCount - 1;
	} -> Skip;
	
VisitorSystem() = || k:{0..NoOfVisitors-1}@(Visitor(k));
//#alphabet TickCounter {i:{0..maxTime}@timer.i};
TickCounter(t) = ([t + 1 < maxTime] timeTick {tick = t + 1} -> TickCounter(t + 1)) [] ([t == maxTime] endTick -> Skip);
VisitorAndTickSystem() = TickCounter(0) || VisitorSystem(); 

#define allCusHappy (lobbyCount == 0 && numVisAll == NoOfVisitors);
#assert VisitorAndTickSystem() reaches allCusHappy;
#assert VisitorAndTickSystem() reaches allCusHappy with min(tick);
#assert System() deadlockfree;
#assert VisitorAndTickSystem() deadlockfree;
		  
//TODO: assert if at at anytime, event cannot hold customers